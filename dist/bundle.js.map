{"version":3,"sources":["webpack:///webpack/bootstrap 335bc9257020e344a740","webpack:///external \"PIXI\"","webpack:///./src/scene.ts","webpack:///./src/index.ts","webpack:///./src/app.ts","webpack:///./src/scene-main.ts","webpack:///./src/scene-splash.ts","webpack:///./src/scene-game.ts","webpack:///node_modules/browser-pack/_prelude.js","webpack:///src/AnimatedParticle.js","webpack:///src/Emitter.js","webpack:///src/Particle.js","webpack:///src/ParticleUtils.js","webpack:///src/PathParticle.js","webpack:///src/particles.js","webpack:///src"],"names":["f","module","exports","define","amd","g","window","global","self","this","pixiParticles","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","ParticleUtils","Particle","Texture","PIXI","AnimatedParticle","emitter","textures","duration","framerate","elapsed","loop","prototype","p","Object","create","init","Particle_init","maxLife","applyArt","art","update","delta","Particle_update","frame","texture","EMPTY_TEXTURE","Particle_destroy","destroy","parseArt","data","j","tex","outTextures","output","push","fromImage","dupe","count","ParticleContainer","particles","ticker","shared","Emitter","particleParent","particleImages","config","_particleConstructor","startAlpha","endAlpha","startSpeed","endSpeed","minimumSpeedMultiplier","acceleration","maxSpeed","NaN","startScale","endScale","minimumScaleMultiplier","startColor","endColor","minLifetime","maxLifetime","minStartRotation","maxStartRotation","noRotation","minRotationSpeed","maxRotationSpeed","particleBlendMode","customEase","extraData","_frequency","maxParticles","emitterLifetime","spawnPos","spawnType","_spawnFunc","spawnRect","spawnCircle","particlesPerWave","particleSpacing","angleStart","rotation","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parentIsPC","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_origArt","_autoUpdate","_destroyWhenComplete","parent","recycle","rotate","updateSpawnPos","updateOwnerPos","helperPoint","Point","defineProperty","get","set","value","cleanup","particle","next","removeChild","Array","isArray","slice","partClass","alpha","start","end","speed","x","y","scale","color","hexToRGB","startRotation","min","max","rotationSpeed","lifetime","getBlendMode","blendMode","ease","generateEase","parseData","_spawnRect","Rectangle","w","h","_spawnCircle","Circle","_spawnRing","minRadius","minR","_spawnBurst","_spawnPoint","frequency","pos","clone","emit","undefined","autoUpdate","prev","visible","newRot","diff","rotatePoint","resetPositionTracking","remove","add","playOnceAndDestroy","settings","TARGET_FPMS","prevX","prevY","curX","curY","Math","random","emitPosX","emitPosY","lerp","len","rand","particleConstructor","floor","children","shift","pop","index","indexOf","splice","unshift","addChildAt","addChild","position","width","height","radius","angle","Sprite","anchor","velocity","age","_sR","_sG","_sB","_eR","_eG","_eB","_doAlpha","_doScale","_doSpeed","_doAcceleration","_doColor","_doNormalMovement","_oneOverLife","kill","DEG_TO_RADS","tint","combineRGBComponents","normalize","scaleBy","currentSpeed","b","atan2","Sprite_Destroy","verbose","baseTexture","console","warn","BLEND_MODES","blendModes","PI","empty","EMPTY","on","once","sin","c","cos","xnew","ynew","point","oneOverLen","sqrt","charAt","substr","parseInt","segments","qty","oneOverQty","simpleEase","time","cp","name","NORMAL","toUpperCase","replace","PathParticle","path","initialRotation","initialPosition","movement","MATH_FUNCS","WHITELISTER","RegExp","parsePath","pathString","rtn","matches","match","join","eval","error","GLOBAL","prop"],"mappings":"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","file":"./dist/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 335bc9257020e344a740","module.exports = PIXI;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"PIXI\"\n// module id = 0\n// module chunks = 0","import * as PIXI from 'pixi.js';\nimport App from './app';\n\nclass Scene {\n\tanimationId: number;\n\tstage: PIXI.Container = new PIXI.Container();\n\tapp: App;\n\n\tconstructor(app: App) {\n\t\tthis.app = app;\n\t}\n\n\tpublic play = () => {\n\t\tthis.animationId = requestAnimationFrame(this.play);\t\n\t\tthis.app.renderer.render(this.stage);\t\t\n\t}\n\n\tpublic stop = () => {\n\t\tcancelAnimationFrame(this.animationId);\n\t\tthis.stage.removeChildren();\n\t\tthis.stage.destroy(true);\n\t}\n}\n\nexport default Scene;\n\n\n// WEBPACK FOOTER //\n// ./src/scene.ts","import App from './app.ts';\n\nnew App().start();\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import * as PIXI from 'pixi.js';\nimport Scene from './scene';\nimport Main from './scene-main';\nimport Splash from './scene-splash';\nimport Game from './scene-game';\n\nclass App {\n\n\tcurrentScene: any;\n\tscenes: any = {};\n\trenderer: any;\n\n\tconstructor() {\n\t\tthis.renderer = PIXI.autoDetectRenderer(800, 600, {});\n\t\tdocument.body.appendChild(this.renderer.view);\n\n\t\tthis.scenes.splash = new Splash(this);\n\t\tthis.scenes.main = new Main(this);\n\t\tthis.scenes.game = new Game(this);\n\t}\n\n\tpublic setScene = (scene: any) => {\n\t\tif (this.currentScene) this.currentScene.stop();\n\t\tthis.currentScene = scene;\n\t\tscene.start();\n\t}\n\n\tpublic start() {\n\t\tthis.setScene(this.scenes.splash);\n\t}\n\n}\n\nexport default App;\n\n\n// WEBPACK FOOTER //\n// ./src/app.ts","import * as PIXI from 'pixi.js';\nimport App from './app';\nimport Scene from './scene';\n\nclass Main extends Scene {\n\n\tconstructor(app: App) {\n\t\tsuper(app);\n\n\t\tvar texture = PIXI.Texture.fromImage('resources/logo.png');\n\t\tvar logo = new PIXI.Sprite(texture);\n\t\tlogo.position.x = 240;\n\t\tlogo.position.y = 50;\n\t\tlogo.scale.x = 0.5;\n\t\tlogo.scale.y = 0.5;\n\t\tthis.stage.addChild(logo);\n\n\t\tvar style = new PIXI.TextStyle({\n\t\t    fontFamily: 'Arial',\n\t\t    fontSize: 36,\n\t\t    fontStyle: 'italic',\n\t\t    fontWeight: 'bold',\n\t\t    fill: ['#ffffff', '#00ff99'], // gradient\n\t\t    stroke: '#4a1850',\n\t\t    strokeThickness: 5,\n\t\t    dropShadow: true,\n\t\t    dropShadowColor: '#000000',\n\t\t    dropShadowBlur: 4,\n\t\t    dropShadowAngle: Math.PI / 6,\n\t\t    dropShadowDistance: 6,\n\t\t    wordWrap: true,\n\t\t    wordWrapWidth: 440\n\t\t});\n\n\t\tvar mouseover = function() {\n\t\t\tthis.scale.x = 1.1;\n\t\t\tthis.scale.y = 1.1;\n\t\t}\n\t\tvar mouseout = function() {\n\t\t\tthis.scale.x = 1;\n\t\t\tthis.scale.y = 1;\n\t\t}\n\n\t\tvar game1 = new PIXI.Text('GAME 1', style);\n\t\tgame1.x = 320;\n\t\tgame1.y = 250;\n\t\tgame1.interactive = true;\n\t\tgame1.on('mouseover', mouseover);\n\t\tgame1.on('mouseout', mouseout);\n\t\tgame1.on('mousedown', this.toGame);\n\t\tthis.stage.addChild(game1);\n\n\t\tvar game2 = new PIXI.Text('GAME 2', style);\n\t\tgame2.x = 320;\n\t\tgame2.y = 300;\n\t\tgame2.interactive = true;\n\t\tgame2.on('mouseover', mouseover);\n\t\tgame2.on('mouseout', mouseout);\n\t\tgame2.on('mousedown', this.toGame);\t\t\n\t\tthis.stage.addChild(game2);\n\n\t\tvar game3 = new PIXI.Text('GAME 3', style);\n\t\tgame3.x = 320;\n\t\tgame3.y = 350;\n\t\tgame3.interactive = true;\n\t\tgame3.on('mouseover', mouseover);\n\t\tgame3.on('mouseout', mouseout);\n\t\tgame3.on('mousedown', this.toGame);\t\t\n\t\tthis.stage.addChild(game3);\n\n\t\tvar exit = new PIXI.Text('EXIT', style);\n\t\texit.x = 320;\n\t\texit.y = 400;\n\t\texit.interactive = true;\n\t\texit.on('mouseover', mouseover);\n\t\texit.on('mouseout', mouseout);\n\t\texit.on('mousedown', function(){\n\t\t\twindow.location.href = 'http://www.disney.com';\n\t\t});\t\t\n\t\tthis.stage.addChild(exit);\t\t\n\t}\n\n\tstart() {\n\t\tthis.play();\n\t}\n\n\ttoGame = () => {\n\t\tthis.app.setScene(this.app.scenes.game);\n\t}\n\n}\n\nexport default Main;\n\n\n// WEBPACK FOOTER //\n// ./src/scene-main.ts","import * as PIXI from 'pixi.js';\nimport App from './app';\nimport Scene from './scene';\n\nclass Splash extends Scene {\n\n\trequestId: number;\n\tlogo: PIXI.Sprite;\n\tfadeout: boolean;\n\n\tconstructor(app: App) {\n\t\tsuper(app);\n\n\t\tvar texture = PIXI.Texture.fromImage('resources/logo.png');\n\t\tvar logo = new PIXI.Sprite(texture);\n\t\tlogo.position.x = 80;\n\t\tlogo.position.y = 100;\n\t\tthis.logo = logo;\n\t\tthis.stage.addChild(logo);\n\t\tthis.app.renderer.render(this.stage);\t\t\n\t}\n\n\tpublic start = () => {\n\t\tthis.play();\n\n\t\t//after 2seconds set the logo to blur out and then after 1 second lets go to main scene\n\t\tsetTimeout(() => { \n\t\t\tthis.fadeout = true;\n\t\t\tsetTimeout(() => { this.app.setScene(this.app.scenes.main) },1000);\n\t\t}, 2000);\n\t}\n\n\tpublic play = () => {\n\t\tif (this.fadeout) {\n\t\t\tthis.logo.alpha -= 0.02;\n\t\t}\n\t\tthis.animationId = requestAnimationFrame(this.play);\t\n\t\tthis.app.renderer.render(this.stage);\t\t\n\t}\t\n\n}\n\nexport default Splash;\n\n\n// WEBPACK FOOTER //\n// ./src/scene-splash.ts","import * as PIXI from 'pixi.js';\nimport App from './app';\nimport Scene from './scene';\nimport * as Particles from 'pixi-particles';\n\nclass Game extends Scene {\n\t\n\tcloseBackground: PIXI.extras.TilingSprite;\n\tfarBackground: PIXI.extras.TilingSprite;\n\tplayer: PIXI.Sprite;\n\tshots: PIXI.Sprite[];\n\tfighters: PIXI.Sprite[];\n\tgameEnded: boolean = false;\n\telapsed: number = Date.now();\n\texplosion: Particles.Emitter;\n\n\tconstructor(app: App) {\n\t\tsuper(app);\n\t\tthis.stage.interactive = true;\n\t\tthis.createBackground();\n\t\tthis.createPlayer();\n\t\tthis.createExplosion();\n\t}\n\n\tpublic start = () => {\n\t\tthis.createEnemy();\t\t\n\t\tthis.play();\n\t}\n\n\tcreateEnemy() {\n\t\tthis.fighters = [];\n\t\tthis.createTiefighter();\n\t}\n\n\tcreateTiefighter = () => {\n\t\tvar texture = PIXI.Texture.fromImage('resources/tiefighter.png');\n\t\tvar tiefighter = new PIXI.Sprite(texture);\n\t\ttiefighter.position.x = 800;\n\t\ttiefighter.position.y = Math.floor(Math.random() * 600) + 1;\n\t\ttiefighter.width = 50;\n\t\ttiefighter.height = 58;\n\t\tthis.stage.addChild(tiefighter);\n\t\tthis.fighters.push(tiefighter);\n\t\tsetTimeout(this.createTiefighter, 1000);\n\t};\n\n\tcreatePlayer() {\n\t\tvar playerTexture = PIXI.Texture.fromImage('resources/falcon.png');\n\t\tvar sprite = new PIXI.Sprite(playerTexture);\n\t\tsprite.anchor.x = 0.5;\n\t\tsprite.anchor.y = 0.5;\n\t\tsprite.position.x = 40;\n\t\tsprite.position.y = 300;\n\t\tsprite.width = 100;\n\t\tsprite.height = 41;\n\n\t\tthis.player = sprite;\n\t\tthis.stage.addChild(sprite);\n\n\t\tthis.stage.on(\"mousemove\", (e:any) => {\n\t\t\tif (this.gameEnded) return;\n\t\t    this.player.x = e.data.global.x;\n\t\t    this.player.y = e.data.global.y;\n\t\t});\n\n\t\tthis.shots = [];\n\t\tthis.stage.on(\"mousedown\", (e:any) => {\n\t\t\tif(this.gameEnded) return;\n\t\t    var y = e.data.global.y;\n\t\t    var x = e.data.global.x;\n\t\t\tvar projectileTexture = PIXI.Texture.fromImage('resources/greenlaser.png');\n\t\t\tvar projectile = new PIXI.Sprite(projectileTexture);\n\t\t\tprojectile.position.x = x;\n\t\t\tprojectile.position.y = y;\n\t\t\tprojectile.scale.x = 0.1;\n\t\t\tprojectile.scale.y = 0.1;\t\n\t\t\tthis.stage.addChild(projectile);\n\t\t\tthis.shots.push(projectile);\n\t\t});\t\t\n\t}\n\n\tcreateBackground() {\n\t\tvar farTexture = PIXI.Texture.fromImage('resources/stars.png');\n\t\tvar far = new PIXI.extras.TilingSprite(farTexture, 1024, 600);\n\t\tfar.position.x = 0;\n\t\tfar.position.y = 0;\n\t\tfar.tilePosition.x = 0;\n\t\tfar.tilePosition.y = 0;\n\t\tthis.stage.addChild(far);\n\n\t\tvar closeTexture = PIXI.Texture.fromImage('resources/asteroids.png');\n\t\tvar close = new PIXI.extras.TilingSprite(closeTexture, 1170, 300);\n\t\tclose.position.x = 0;\n\t\tclose.position.y = 300;\n\t\tclose.tilePosition.x = 0;\n\t\tclose.tilePosition.y = 300;\n\t\tthis.stage.addChild(close);\n\n\t\tthis.farBackground = far;\n\t\tthis.closeBackground = close;\n\t}\n\n\tpublic play = () => {\n\t\t//animate background\n\t\tthis.farBackground.tilePosition.x -= 0.5;\n\t\tthis.closeBackground.tilePosition.x -= 3;\n\n\t    //animate shots\n\t    for (var i = 0; i < this.shots.length; i++) {\n\t    \tvar shot = this.shots[i];\n\t    \tif (shot.position.x > 900) {\n\t    \t\tshot.destroy();\n\t    \t\tthis.shots.splice(i,1);\n\t    \t\ti--;\n\t    \t\tcontinue;\n\t    \t}\n\t    \telse shot.position.x += 10;\n\n\t    \t//check fighter collision\n\t    \tfor (var j = 0; j < this.fighters.length; j++) {\n\t    \t\tvar fighter = this.fighters[j];\n\t    \t\tif (this.collision(shot, fighter)) {\n\t\t    \t\tthis.explodeAt(fighter.x, fighter.y);\n\t    \t\t\tfighter.destroy();\n\t\t    \t\tthis.fighters.splice(j,1);\n\t\t    \t\tshot.destroy();\n\t\t    \t\tthis.shots.splice(i,1);\n\t\t    \t\tbreak;\n\t    \t\t}\n\t    \t}\n\t    }\n\n\t    //animate fighters\n\t    for (var i = 0; i < this.fighters.length; i++) {\n\t    \tvar fighter = this.fighters[i];\n\t    \tif (fighter.position.x < -100) {\n\t    \t\tfighter.destroy();\n\t    \t\tthis.fighters.splice(i,1);\n\t    \t\ti--;\n\t    \t\tcontinue;\n\t    \t} else fighter.position.x -= 5;\n\n\t    \t//check player collision\n\t    \tif (!this.gameEnded && this.collision(this.player, fighter)) {\n\t\t\t\tthis.explodeAt(this.player.x, this.player.y);\n\t\t\t\tthis.player.destroy();\n\t\t\t\tthis.gameEnded = true;\n\t    \t\tthis.gameOver();\n\t    \t\tbreak;\n\t    \t}\n\t    }\n\n\t    //update explosion emitter\n\t\tvar now = Date.now();\n\t\tif (this.explosion) this.explosion.update((now - this.elapsed) * 0.001);\n\t\tthis.elapsed = now;\n\n\t\t//call animation renderer\n\t\tthis.animationId = requestAnimationFrame(this.play);\t\n\t\tthis.app.renderer.render(this.stage);\t\t\n\t}\n\n\t//simple rectangular collision\n\tcollision(a: PIXI.Sprite, b: PIXI.Sprite) {\n\t\tif (a.position.x < b.position.x + b.width &&\n\t\t   a.position.x + a.width > b.position.x &&\n\t\t   a.position.y < b.position.y + b.height &&\n\t\t   a.height + a.position.y > b.position.y) {\n\t\t   return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tcreateExplosion() {\n\t\tthis.explosion = new Particles.Emitter(\n\t\t\tthis.stage,\n\t\t\t[PIXI.Texture.fromImage('resources/particle.png')],\n\t\t\t{\n\t\t\t\t\"alpha\": {\n\t\t\t\t\t\"start\": 0.8,\n\t\t\t\t\t\"end\": 0.1\n\t\t\t\t},\n\t\t\t\t\"scale\": {\n\t\t\t\t\t\"start\": 1,\n\t\t\t\t\t\"end\": 0.3\n\t\t\t\t},\n\t\t\t\t\"color\": {\n\t\t\t\t\t\"start\": \"fd1111\",\n\t\t\t\t\t\"end\": \"f7a134\"\n\t\t\t\t},\n\t\t\t\t\"speed\": {\n\t\t\t\t\t\"start\": 200,\n\t\t\t\t\t\"end\": 200\n\t\t\t\t},\n\t\t\t\t\"startRotation\": {\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"max\": 0\n\t\t\t\t},\n\t\t\t\t\"rotationSpeed\": {\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"max\": 0\n\t\t\t\t},\n\t\t\t\t\"lifetime\": {\n\t\t\t\t\t\"min\": 0.5,\n\t\t\t\t\t\"max\": 0.5\n\t\t\t\t},\n\t\t\t\t\"frequency\": 0.1,\n\t\t\t\t\"emitterLifetime\": 0.31,\n\t\t\t\t\"maxParticles\": 1000,\n\t\t\t\t\"pos\": {\n\t\t\t\t\t\"x\": 10,\n\t\t\t\t\t\"y\": 10\n\t\t\t\t},\n\t\t\t\t\"addAtBack\": false,\n\t\t\t\t\"spawnType\": \"burst\",\n\t\t\t\t\"particlesPerWave\": 10,\n\t\t\t\t\"particleSpacing\": 0,\n\t\t\t\t\"angleStart\": 0\n\t\t\t}\t\t\t\n\t\t);\n\t}\n\n\texplodeAt(x: number,y: number) {\n\t\tthis.explosion.emit = true;\n\t\tthis.explosion.resetPositionTracking();\n\t\tthis.explosion.updateOwnerPos(x,y);\n\t}\n\n\tgameOver = () => {\n\t\tsetTimeout(() => {\n\t\t\tconsole.log('lollll');\n\t\t\tvar gameOver = new PIXI.Text('GAME OVER BABY', {\n\t\t\t\tfontFamily: 'Arial',\n\t\t    \tfontSize: 36,\n\t\t    \tfill: ['#ffffff', '#ffffff'],\n\t\t    \tfontWeight: 'bold'\n\t\t    });\n\t\t\tgameOver.x = 250;\n\t\t\tgameOver.y = 270;\n\n\t\t\tthis.stage.addChild(gameOver);\n\t\t}, 3000);\n\t}\n\n}\n\nexport default Game;\n\n\n// WEBPACK FOOTER //\n// ./src/scene-game.ts","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})\n\n\n// WEBPACK FOOTER //\n// node_modules/browser-pack/_prelude.js","\"use strict\";\n\nvar ParticleUtils = require(\"./ParticleUtils\"),\n\tParticle = require(\"./Particle\"),\n\tTexture = PIXI.Texture;\n\n/**\n * An individual particle image with an animation. Art data passed to the emitter must be\n * formatted in a particular way for AnimatedParticle to be able to handle it:\n *\n *     {\n *         //framerate is required. It is the animation speed of the particle in frames per\n *         //second.\n *         //A value of \"matchLife\" causes the animation to match the lifetime of an individual\n *         //particle, instead of at a constant framerate. This causes the animation to play\n *         //through one time, completing when the particle expires.\n *         framerate: 6,\n *         //loop is optional, and defaults to false.\n *         loop: true,\n *         //textures is required, and can be an array of any (non-zero) length.\n *         textures: [\n *             //each entry represents a single texture that should be used for one or more\n *             //frames. Any strings will be converted to Textures with Texture.fromImage().\n *             //Instances of PIXI.Texture will be used directly.\n *             \"animFrame1.png\",\n *             //entries can be an object with a 'count' property, telling AnimatedParticle to\n *             //use that texture for 'count' frames sequentially.\n *             {\n *                 texture: \"animFrame2.png\",\n *                 count: 3\n *             },\n *             \"animFrame3.png\"\n *         ]\n *     }\n *\n * @memberof PIXI.particles\n * @class AnimatedParticle\n * @extends PIXI.particles.Particle\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this AnimatedParticle.\n */\nvar AnimatedParticle = function(emitter)\n{\n\tParticle.call(this, emitter);\n\n\t/**\n\t * Texture array used as each frame of animation, similarly to how MovieClip works.\n\t * @property {Array} textures\n\t * @private\n\t */\n\tthis.textures = null;\n\n\t/**\n\t * Duration of the animation, in seconds.\n\t * @property {Number} duration\n\t * @private\n\t */\n\tthis.duration = 0;\n\n\t/**\n\t * Animation framerate, in frames per second.\n\t * @property {Number} framerate\n\t * @private\n\t */\n\tthis.framerate = 0;\n\n\t/**\n\t * Animation time elapsed, in seconds.\n\t * @property {Number} elapsed\n\t * @private\n\t */\n\tthis.elapsed = 0;\n\n\t/**\n\t * If this particle animation should loop.\n\t * @property {Boolean} loop\n\t * @private\n\t */\n\tthis.loop = false;\n};\n\n// Reference to the super class\nvar s = Particle.prototype;\n// Reference to the prototype\nvar p = AnimatedParticle.prototype = Object.create(s);\n\n/**\n * Initializes the particle for use, based on the properties that have to\n * have been set already on the particle.\n * @method PIXI.particles.AnimatedParticle#init\n */\np.init = function()\n{\n\tthis.Particle_init();\n\n\tthis.elapsed = 0;\n\n\t//if the animation needs to match the particle's life, then cacluate variables\n\tif(this.framerate < 0)\n\t{\n\t\tthis.duration = this.maxLife;\n\t\tthis.framerate = this.textures.length / this.duration;\n\t}\n};\n\n/**\n * Sets the textures for the particle.\n * @method PIXI.particles.AnimatedParticle#applyArt\n * @param {Array} art An array of PIXI.Texture objects for this animated particle.\n */\np.applyArt = function(art)\n{\n\tthis.textures = art.textures;\n\tthis.framerate = art.framerate;\n\tthis.duration = art.duration;\n\tthis.loop = art.loop;\n};\n\n/**\n * Updates the particle.\n * @method PIXI.particles.AnimatedParticle#update\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n */\np.update = function(delta)\n{\n\t//only animate the particle if it is still alive\n\tif(this.Particle_update(delta) >= 0)\n\t{\n\t\tthis.elapsed += delta;\n\t\tif(this.elapsed > this.duration)\n\t\t{\n\t\t\t//loop elapsed back around\n\t\t\tif(this.loop)\n\t\t\t\tthis.elapsed = this.elapsed % this.duration;\n\t\t\t//subtract a small amount to prevent attempting to go past the end of the animation\n\t\t\telse\n\t\t\t\tthis.elapsed = this.duration - 0.000001;\n\t\t}\n\t\tvar frame = (this.elapsed * this.framerate + 0.0000001) | 0;\n\t\tthis.texture = this.textures[frame] || ParticleUtils.EMPTY_TEXTURE;\n\t}\n};\n\np.Particle_destroy = Particle.prototype.destroy;\n/**\n * Destroys the particle, removing references and preventing future use.\n * @method PIXI.particles.AnimatedParticle#destroy\n */\np.destroy = function()\n{\n\tthis.Particle_destroy();\n\tthis.textures = null;\n};\n\n/**\n * Checks over the art that was passed to the Emitter's init() function, to do any special\n * modifications to prepare it ahead of time.\n * @method PIXI.particles.AnimatedParticle.parseArt\n * @static\n * @param  {Array} art The array of art data, properly formatted for AnimatedParticle.\n * @return {Array} The art, after any needed modifications.\n */\nAnimatedParticle.parseArt = function(art)\n{\n\tvar i, data, output = [], j, textures, tex, outTextures;\n\tfor(i = 0; i < art.length; ++i)\n\t{\n\t\tdata = art[i];\n\t\tart[i] = output = {};\n\t\toutput.textures = outTextures = [];\n\t\ttextures = data.textures;\n\t\tfor(j = 0; j < textures.length; ++j)\n\t\t{\n\t\t\ttex = textures[j];\n\t\t\tif(typeof tex == \"string\")\n\t\t\t\toutTextures.push(Texture.fromImage(tex));\n\t\t\telse if(tex instanceof Texture)\n\t\t\t\toutTextures.push(tex);\n\t\t\t//assume an object with extra data determining duplicate frame data\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar dupe = tex.count || 1;\n\t\t\t\tif(typeof tex.texture == \"string\")\n\t\t\t\t\ttex = Texture.fromImage(tex.texture);\n\t\t\t\telse// if(tex.texture instanceof Texture)\n\t\t\t\t\ttex = tex.texture;\n\t\t\t\tfor(; dupe > 0; --dupe)\n\t\t\t\t{\n\t\t\t\t\toutTextures.push(tex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//use these values to signify that the animation should match the particle life time.\n\t\tif(data.framerate == \"matchLife\")\n\t\t{\n\t\t\t//-1 means that it should be calculated\n\t\t\toutput.framerate = -1;\n\t\t\toutput.duration = 0;\n\t\t\toutput.loop = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//determine if the animation should loop\n\t\t\toutput.loop = !!data.loop;\n\t\t\t//get the framerate, default to 60\n\t\t\toutput.framerate = data.framerate > 0 ? data.framerate : 60;\n\t\t\t//determine the duration\n\t\t\toutput.duration = outTextures.length / output.framerate;\n\t\t}\n\t}\n\n\treturn art;\n};\n\nmodule.exports = AnimatedParticle;\n\n\n// WEBPACK FOOTER //\n// src/AnimatedParticle.js","\"use strict\";\n\nvar ParticleUtils = require(\"./ParticleUtils\"),\n\tParticle = require(\"./Particle\"),\n\tParticleContainer = PIXI.particles.ParticleContainer || PIXI.ParticleContainer,\n\tticker = PIXI.ticker.shared;\n\n/**\n * A particle emitter.\n * @memberof PIXI.particles\n * @class Emitter\n * @constructor\n * @param {PIXI.Container} particleParent The container to add the\n *                                                     particles to.\n * @param {Array|PIXI.Texture|String} [particleImages] A texture or array of textures to use\n *                                                     for the particles. Strings will be turned\n *                                                     into textures via Texture.fromImage().\n * @param {Object} [config] A configuration object containing settings for the emitter.\n * @param {Boolean} [config.emit=true] If config.emit is explicitly passed as false, the Emitter\n *                                     will start disabled.\n * @param {Boolean} [config.autoUpdate=false] If config.emit is explicitly passed as true, the Emitter\n *                                     will automatically call update via the PIXI shared ticker.\n */\nvar Emitter = function(particleParent, particleImages, config)\n{\n\t/**\n\t * The constructor used to create new particles. The default is\n\t * the built in particle class.\n\t * @property {Function} _particleConstructor\n\t * @private\n\t */\n\tthis._particleConstructor = Particle;\n\t//properties for individual particles\n\t/**\n\t * An array of PIXI Texture objects.\n\t * @property {Array} particleImages\n\t */\n\tthis.particleImages = null;\n\t/**\n\t * The starting alpha of all particles.\n\t * @property {Number} startAlpha\n\t * @default 1\n\t */\n\tthis.startAlpha = 1;\n\t/**\n\t * The ending alpha of all particles.\n\t * @property {Number} endAlpha\n\t * @default 1\n\t */\n\tthis.endAlpha = 1;\n\t/**\n\t * The starting speed of all particles.\n\t * @property {Number} startSpeed\n\t * @default 0\n\t */\n\tthis.startSpeed = 0;\n\t/**\n\t * The ending speed of all particles.\n\t * @property {Number} endSpeed\n\t * @default 0\n\t */\n\tthis.endSpeed = 0;\n\t/**\n\t * A minimum multiplier for the speed of a particle at both start and\n\t * end. A value between minimumSpeedMultiplier and 1 is randomly generated\n\t * and multiplied with startSpeed and endSpeed to provide the actual\n\t * startSpeed and endSpeed for each particle.\n\t * @property {Number} minimumSpeedMultiplier\n\t * @default 1\n\t */\n\tthis.minimumSpeedMultiplier = 1;\n\t/**\n\t * Acceleration to apply to particles. Using this disables\n\t * any interpolation of particle speed. If the particles do\n\t * not have a rotation speed, then they will be rotated to\n\t * match the direction of travel.\n\t * @property {PIXI.Point} acceleration\n\t * @default null\n\t */\n\tthis.acceleration = null;\n\t/**\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n\t * will disable the maximum speed.\n\t * @property {Number} maxSpeed\n\t * @default NaN\n\t */\n\tthis.maxSpeed = NaN;\n\t/**\n\t * The starting scale of all particles.\n\t * @property {Number} startScale\n\t * @default 1\n\t */\n\tthis.startScale = 1;\n\t/**\n\t * The ending scale of all particles.\n\t * @property {Number} endScale\n\t * @default 1\n\t */\n\tthis.endScale = 1;\n\t/**\n\t * A minimum multiplier for the scale of a particle at both start and\n\t * end. A value between minimumScaleMultiplier and 1 is randomly generated\n\t * and multiplied with startScale and endScale to provide the actual\n\t * startScale and endScale for each particle.\n\t * @property {Number} minimumScaleMultiplier\n\t * @default 1\n\t */\n\tthis.minimumScaleMultiplier = 1;\n\t/**\n\t * The starting color of all particles, as red, green, and blue uints from 0-255.\n\t * @property {Array} startColor\n\t */\n\tthis.startColor = null;\n\t/**\n\t * The ending color of all particles, as red, green, and blue uints from 0-255.\n\t * @property {Array} endColor\n\t */\n\tthis.endColor = null;\n\t/**\n\t * The minimum lifetime for a particle, in seconds.\n\t * @property {Number} minLifetime\n\t */\n\tthis.minLifetime = 0;\n\t/**\n\t * The maximum lifetime for a particle, in seconds.\n\t * @property {Number} maxLifetime\n\t */\n\tthis.maxLifetime = 0;\n\t/**\n\t * The minimum start rotation for a particle, in degrees. This value\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\n\t * @property {Number} minStartRotation\n\t */\n\tthis.minStartRotation = 0;\n\t/**\n\t * The maximum start rotation for a particle, in degrees. This value\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\n\t * @property {Number} maxStartRotation\n\t */\n\tthis.maxStartRotation = 0;\n\t/**\n\t * If no particle rotation should occur. Starting rotation will still\n\t * affect the direction in which particles move. If the rotation speed\n\t * is set, then this will be ignored.\n\t * @property {Boolean} maxStartRotation\n\t */\n\tthis.noRotation = false;\n\t/**\n\t * The minimum rotation speed for a particle, in degrees per second.\n\t * This only visually spins the particle, it does not change direction\n\t * of movement.\n\t * @property {Number} minRotationSpeed\n\t */\n\tthis.minRotationSpeed = 0;\n\t/**\n\t * The maximum rotation speed for a particle, in degrees per second.\n\t * This only visually spins the particle, it does not change direction\n\t * of movement.\n\t * @property {Number} maxRotationSpeed\n\t */\n\tthis.maxRotationSpeed = 0;\n\t/**\n\t * The blend mode for all particles, as named by PIXI.blendModes.\n\t * @property {int} particleBlendMode\n\t */\n\tthis.particleBlendMode = 0;\n\t/**\n\t * An easing function for nonlinear interpolation of values. Accepts a single\n\t * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n\t * from 0-1, inclusive.\n\t * @property {Function} customEase\n\t */\n\tthis.customEase = null;\n\t/**\n\t *\tExtra data for use in custom particles. The emitter doesn't look inside, but\n\t *\tpasses it on to the particle to use in init().\n\t *\t@property {Object} extraData\n\t */\n\tthis.extraData = null;\n\t//properties for spawning particles\n\t/**\n\t * Time between particle spawns in seconds.\n\t * @property {Number} _frequency\n\t * @private\n\t */\n\tthis._frequency = 1;\n\t/**\n\t * Maximum number of particles to keep alive at a time. If this limit\n\t * is reached, no more particles will spawn until some have died.\n\t * @property {int} maxParticles\n\t * @default 1000\n\t */\n\tthis.maxParticles = 1000;\n\t/**\n\t * The amount of time in seconds to emit for before setting emit to false.\n\t * A value of -1 is an unlimited amount of time.\n\t * @property {Number} emitterLifetime\n\t * @default -1\n\t */\n\tthis.emitterLifetime = -1;\n\t/**\n\t * Position at which to spawn particles, relative to the emitter's owner's origin.\n\t * For example, the flames of a rocket travelling right might have a spawnPos\n\t * of {x:-50, y:0}.\n\t * to spawn at the rear of the rocket.\n\t * To change this, use updateSpawnPos().\n\t * @property {PIXI.Point} spawnPos\n\t * @readOnly\n\t */\n\tthis.spawnPos = null;\n\t/**\n\t * How the particles will be spawned. Valid types are \"point\", \"rectangle\",\n\t * \"circle\", \"burst\", \"ring\".\n\t * @property {String} spawnType\n\t * @readOnly\n\t */\n\tthis.spawnType = null;\n\t/**\n\t * A reference to the emitter function specific to the spawn type.\n\t * @property {Function} _spawnFunc\n\t * @private\n\t */\n\tthis._spawnFunc = null;\n\t/**\n\t * A rectangle relative to spawnPos to spawn particles inside if the spawn type is \"rect\".\n\t * @property {PIXI.Rectangle} spawnRect\n\t */\n\tthis.spawnRect = null;\n\t/**\n\t * A circle relative to spawnPos to spawn particles inside if the spawn type is \"circle\".\n\t * @property {PIXI.Circle} spawnCircle\n\t */\n\tthis.spawnCircle = null;\n\t/**\n\t * Number of particles to spawn each wave in a burst.\n\t * @property {int} particlesPerWave\n\t * @default 1\n\t */\n\tthis.particlesPerWave = 1;\n\t/**\n\t * Spacing between particles in a burst. 0 gives a random angle for each particle.\n\t * @property {Number} particleSpacing\n\t * @default 0\n\t */\n\tthis.particleSpacing = 0;\n\t/**\n\t * Angle at which to start spawning particles in a burst.\n\t * @property {Number} angleStart\n\t * @default 0\n\t */\n\tthis.angleStart = 0;\n\t/**\n\t * Rotation of the emitter or emitter's owner in degrees. This is added to\n\t * the calculated spawn angle.\n\t * To change this, use rotate().\n\t * @property {Number} rotation\n\t * @default 0\n\t * @readOnly\n\t */\n\tthis.rotation = 0;\n\t/**\n\t * The world position of the emitter's owner, to add spawnPos to when\n\t * spawning particles. To change this, use updateOwnerPos().\n\t * @property {PIXI.Point} ownerPos\n\t * @default {x:0, y:0}\n\t * @readOnly\n\t */\n\tthis.ownerPos = null;\n\t/**\n\t * The origin + spawnPos in the previous update, so that the spawn position\n\t * can be interpolated to space out particles better.\n\t * @property {PIXI.Point} _prevEmitterPos\n\t * @private\n\t */\n\tthis._prevEmitterPos = null;\n\t/**\n\t * If _prevEmitterPos is valid, to prevent interpolation on the first update\n\t * @property {Boolean} _prevPosIsValid\n\t * @private\n\t * @default false\n\t */\n\tthis._prevPosIsValid = false;\n\t/**\n\t * If either ownerPos or spawnPos has changed since the previous update.\n\t * @property {Boolean} _posChanged\n\t * @private\n\t */\n\tthis._posChanged = false;\n\t/**\n\t * If the parent is a ParticleContainer from Pixi V3\n\t * @property {Boolean} _parentIsPC\n\t * @private\n\t */\n\tthis._parentIsPC = false;\n\t/**\n\t * The container to add particles to.\n\t * @property {PIXI.Container} _parent\n\t * @private\n\t */\n\tthis._parent = null;\n\t/**\n\t * If particles should be added at the back of the display list instead of the front.\n\t * @property {Boolean} addAtBack\n\t */\n\tthis.addAtBack = false;\n\t/**\n\t * The current number of active particles.\n\t * @property {Number} particleCount\n\t * @readOnly\n\t */\n\tthis.particleCount = 0;\n\t/**\n\t * If particles should be emitted during update() calls. Setting this to false\n\t * stops new particles from being created, but allows existing ones to die out.\n\t * @property {Boolean} _emit\n\t * @private\n\t */\n\tthis._emit = false;\n\t/**\n\t * The timer for when to spawn particles in seconds, where numbers less\n\t * than 0 mean that particles should be spawned.\n\t * @property {Number} _spawnTimer\n\t * @private\n\t */\n\tthis._spawnTimer = 0;\n\t/**\n\t * The life of the emitter in seconds.\n\t * @property {Number} _emitterLife\n\t * @private\n\t */\n\tthis._emitterLife = -1;\n\t/**\n\t * The particles that are active and on the display list. This is the first particle in a\n\t * linked list.\n\t * @property {Particle} _activeParticlesFirst\n\t * @private\n\t */\n\tthis._activeParticlesFirst = null;\n\t/**\n\t * The particles that are active and on the display list. This is the last particle in a\n\t * linked list.\n\t * @property {Particle} _activeParticlesLast\n\t * @private\n\t */\n\tthis._activeParticlesLast = null;\n\t/**\n\t * The particles that are not currently being used. This is the first particle in a\n\t * linked list.\n\t * @property {Particle} _poolFirst\n\t * @private\n\t */\n\tthis._poolFirst = null;\n\t/**\n\t * The original config object that this emitter was initialized with.\n\t * @property {Object} _origConfig\n\t * @private\n\t */\n\tthis._origConfig = null;\n\t/**\n\t * The original particle image data that this emitter was initialized with.\n\t * @property {PIXI.Texture|Array|String} _origArt\n\t * @private\n\t */\n\tthis._origArt = null;\n\t/**\n\t * If the update function is called automatically from the shared ticker.\n\t * Setting this to false requires calling the update function manually.\n\t * @property {Boolean} _autoUpdate\n\t * @private\n\t */\n\tthis._autoUpdate = false;\n\t/**\n\t * If the emitter should destroy itself when all particles have died out. This is set by\n\t * playOnceAndDestroy();\n\t * @property {Boolean} _destroyWhenComplete\n\t * @private\n\t */\n\tthis._destroyWhenComplete = false;\n\n\t//set the initial parent\n\tthis.parent = particleParent;\n\n\tif(particleImages && config)\n\t\tthis.init(particleImages, config);\n\n\t//save often used functions on the instance instead of the prototype for better speed\n\tthis.recycle = this.recycle;\n\tthis.update = this.update;\n\tthis.rotate = this.rotate;\n\tthis.updateSpawnPos = this.updateSpawnPos;\n\tthis.updateOwnerPos = this.updateOwnerPos;\n};\n\n// Reference to the prototype\nvar p = Emitter.prototype = {};\n\nvar helperPoint = new PIXI.Point();\n\n/**\n * Time between particle spawns in seconds. If this value is not a number greater than 0,\n * it will be set to 1 (particle per second) to prevent infinite loops.\n * @member {Number} PIXI.particles.Emitter#frequency\n */\nObject.defineProperty(p, \"frequency\",\n{\n\tget: function() { return this._frequency; },\n\tset: function(value)\n\t{\n\t\t//do some error checking to prevent infinite loops\n\t\tif(typeof value == \"number\" && value > 0)\n\t\t\tthis._frequency = value;\n\t\telse\n\t\t\tthis._frequency = 1;\n\t}\n});\n\n/**\n * The constructor used to create new particles. The default is\n * the built in Particle class. Setting this will dump any active or\n * pooled particles, if the emitter has already been used.\n * @member {Function} PIXI.particles.Emitter#particleConstructor\n */\nObject.defineProperty(p, \"particleConstructor\",\n{\n\tget: function() { return this._particleConstructor; },\n\tset: function(value)\n\t{\n\t\tif(value != this._particleConstructor)\n\t\t{\n\t\t\tthis._particleConstructor = value;\n\t\t\t//clean up existing particles\n\t\t\tthis.cleanup();\n\t\t\t//scrap all the particles\n\t\t\tfor (var particle = this._poolFirst; particle; particle = particle.next)\n\t\t\t{\n\t\t\t\tparticle.destroy();\n\t\t\t}\n\t\t\tthis._poolFirst = null;\n\t\t\t//re-initialize the emitter so that the new constructor can do anything it needs to\n\t\t\tif(this._origConfig && this._origArt)\n\t\t\t\tthis.init(this._origArt, this._origConfig);\n\t\t}\n\t}\n});\n\n/**\n* The container to add particles to. Settings this will dump any active particles.\n* @member {PIXI.Container} PIXI.particles.Emitter#parent\n*/\nObject.defineProperty(p, \"parent\",\n{\n\tget: function() { return this._parent; },\n\tset: function(value)\n\t{\n\t\t//if our previous parent was a ParticleContainer, then we need to remove\n\t\t//pooled particles from it\n\t\tif (this._parentIsPC) {\n\t\t\tfor (var particle = this._poolFirst; particle; particle = particle.next)\n\t\t\t{\n\t\t\t\tif(particle.parent)\n\t\t\t\t\tparticle.parent.removeChild(particle);\n\t\t\t}\n\t\t}\n\t\tthis.cleanup();\n\t\tthis._parent = value;\n\t\tthis._parentIsPC = ParticleContainer && value && value instanceof ParticleContainer;\n\t}\n});\n\n/**\n * Sets up the emitter based on the config settings.\n * @method PIXI.particles.Emitter#init\n * @param {Array|PIXI.Texture} art A texture or array of textures to use for the particles.\n * @param {Object} config A configuration object containing settings for the emitter.\n */\np.init = function(art, config)\n{\n\tif(!art || !config)\n\t\treturn;\n\t//clean up any existing particles\n\tthis.cleanup();\n\n\t//store the original config and particle images, in case we need to re-initialize\n\t//when the particle constructor is changed\n\tthis._origConfig = config;\n\tthis._origArt = art;\n\n\t//set up the array of data, also ensuring that it is an array\n\tart = Array.isArray(art) ? art.slice() : [art];\n\t//run the art through the particle class's parsing function\n\tvar partClass = this._particleConstructor;\n\tthis.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;\n\t///////////////////////////\n\t// Particle Properties   //\n\t///////////////////////////\n\t//set up the alpha\n\tif (config.alpha)\n\t{\n\t\tthis.startAlpha = config.alpha.start;\n\t\tthis.endAlpha = config.alpha.end;\n\t}\n\telse\n\t\tthis.startAlpha = this.endAlpha = 1;\n\t//set up the speed\n\tif (config.speed)\n\t{\n\t\tthis.startSpeed = config.speed.start;\n\t\tthis.endSpeed = config.speed.end;\n\t\tthis.minimumSpeedMultiplier = config.speed.minimumSpeedMultiplier || 1;\n\t}\n\telse\n\t{\n\t\tthis.minimumSpeedMultiplier = 1;\n\t\tthis.startSpeed = this.endSpeed = 0;\n\t}\n\t//set up acceleration\n\tvar acceleration = config.acceleration;\n\tif(acceleration && (acceleration.x || acceleration.y))\n\t{\n\t\tthis.endSpeed = this.startSpeed;\n\t\tthis.acceleration = new PIXI.Point(acceleration.x, acceleration.y);\n\t\tthis.maxSpeed = config.maxSpeed || NaN;\n\t}\n\telse\n\t\tthis.acceleration = new PIXI.Point();\n\t//set up the scale\n\tif (config.scale)\n\t{\n\t\tthis.startScale = config.scale.start;\n\t\tthis.endScale = config.scale.end;\n\t\tthis.minimumScaleMultiplier = config.scale.minimumScaleMultiplier || 1;\n\t}\n\telse\n\t\tthis.startScale = this.endScale = this.minimumScaleMultiplier = 1;\n\t//set up the color\n\tif (config.color)\n\t{\n\t\tthis.startColor = ParticleUtils.hexToRGB(config.color.start);\n\t\t//if it's just one color, only use the start color\n\t\tif (config.color.start != config.color.end)\n\t\t{\n\t\t\tthis.endColor = ParticleUtils.hexToRGB(config.color.end);\n\t\t}\n\t\telse\n\t\t\tthis.endColor = null;\n\t}\n\t//set up the start rotation\n\tif (config.startRotation)\n\t{\n\t\tthis.minStartRotation = config.startRotation.min;\n\t\tthis.maxStartRotation = config.startRotation.max;\n\t}\n\telse\n\t\tthis.minStartRotation = this.maxStartRotation = 0;\n\tif (config.noRotation &&\n\t\t(this.minStartRotation || this.maxStartRotation))\n\t{\n\t\tthis.noRotation = !!config.noRotation;\n\t}\n\telse\n\t\tthis.noRotation = false;\n\t//set up the rotation speed\n\tif (config.rotationSpeed)\n\t{\n\t\tthis.minRotationSpeed = config.rotationSpeed.min;\n\t\tthis.maxRotationSpeed = config.rotationSpeed.max;\n\t}\n\telse\n\t\tthis.minRotationSpeed = this.maxRotationSpeed = 0;\n\t//set up the lifetime\n\tthis.minLifetime = config.lifetime.min;\n\tthis.maxLifetime = config.lifetime.max;\n\t//get the blend mode\n\tthis.particleBlendMode = ParticleUtils.getBlendMode(config.blendMode);\n\t//use the custom ease if provided\n\tif (config.ease)\n\t{\n\t\tthis.customEase = typeof config.ease == \"function\" ?\n\t\t\t\t\t\t\t\t\t\t\t\t\tconfig.ease :\n\t\t\t\t\t\t\t\t\t\t\t\t\tParticleUtils.generateEase(config.ease);\n\t}\n\telse\n\t\tthis.customEase = null;\n\t//set up the extra data, running it through the particle class's parseData function.\n\tif(partClass.parseData)\n\t\tthis.extraData = partClass.parseData(config.extraData);\n\telse\n\t\tthis.extraData = config.extraData || null;\n\t//////////////////////////\n\t// Emitter Properties   //\n\t//////////////////////////\n\t//reset spawn type specific settings\n\tthis.spawnRect = this.spawnCircle = null;\n\tthis.particlesPerWave = 1;\n\tthis.particleSpacing = 0;\n\tthis.angleStart = 0;\n\tvar spawnCircle;\n\t//determine the spawn function to use\n\tswitch(config.spawnType)\n\t{\n\t\tcase \"rect\":\n\t\t\tthis.spawnType = \"rect\";\n\t\t\tthis._spawnFunc = this._spawnRect;\n\t\t\tvar spawnRect = config.spawnRect;\n\t\t\tthis.spawnRect = new PIXI.Rectangle(spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);\n\t\t\tbreak;\n\t\tcase \"circle\":\n\t\t\tthis.spawnType = \"circle\";\n\t\t\tthis._spawnFunc = this._spawnCircle;\n\t\t\tspawnCircle = config.spawnCircle;\n\t\t\tthis.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\n\t\t\tbreak;\n\t\tcase \"ring\":\n\t\t\tthis.spawnType = \"ring\";\n\t\t\tthis._spawnFunc = this._spawnRing;\n\t\t\tspawnCircle = config.spawnCircle;\n\t\t\tthis.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\n\t\t\tthis.spawnCircle.minRadius = spawnCircle.minR;\n\t\t\tbreak;\n\t\tcase \"burst\":\n\t\t\tthis.spawnType = \"burst\";\n\t\t\tthis._spawnFunc = this._spawnBurst;\n\t\t\tthis.particlesPerWave = config.particlesPerWave;\n\t\t\tthis.particleSpacing = config.particleSpacing;\n\t\t\tthis.angleStart = config.angleStart ? config.angleStart : 0;\n\t\t\tbreak;\n\t\tcase \"point\":\n\t\t\tthis.spawnType = \"point\";\n\t\t\tthis._spawnFunc = this._spawnPoint;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.spawnType = \"point\";\n\t\t\tthis._spawnFunc = this._spawnPoint;\n\t\t\tbreak;\n\t}\n\t//set the spawning frequency\n\tthis.frequency = config.frequency;\n\t//set the emitter lifetime\n\tthis.emitterLifetime = config.emitterLifetime || -1;\n\t//set the max particles\n\tthis.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n\t//determine if we should add the particle at the back of the list or not\n\tthis.addAtBack = !!config.addAtBack;\n\t//reset the emitter position and rotation variables\n\tthis.rotation = 0;\n\tthis.ownerPos = new PIXI.Point();\n\tthis.spawnPos = new PIXI.Point(config.pos.x, config.pos.y);\n\tthis._prevEmitterPos = this.spawnPos.clone();\n\t//previous emitter position is invalid and should not be used for interpolation\n\tthis._prevPosIsValid = false;\n\t//start emitting\n\tthis._spawnTimer = 0;\n\tthis.emit = config.emit === undefined ? true : !!config.emit;\n\tthis.autoUpdate = config.autoUpdate === undefined ? false : !!config.autoUpdate;\n};\n\n/**\n * Recycles an individual particle.\n * @method PIXI.particles.Emitter#recycle\n * @param {Particle} particle The particle to recycle.\n * @private\n */\np.recycle = function(particle)\n{\n\tif(particle.next)\n\t\tparticle.next.prev = particle.prev;\n\tif(particle.prev)\n\t\tparticle.prev.next = particle.next;\n\tif(particle == this._activeParticlesLast)\n\t\tthis._activeParticlesLast = particle.prev;\n\tif(particle == this._activeParticlesFirst)\n\t\tthis._activeParticlesFirst = particle.next;\n\t//add to pool\n\tparticle.prev = null;\n\tparticle.next = this._poolFirst;\n\tthis._poolFirst = particle;\n\t//remove child from display, or make it invisible if it is in a ParticleContainer\n\tif(this._parentIsPC)\n\t{\n\t\tparticle.alpha = 0;\n\t\tparticle.visible = false;\n\t}\n\telse\n\t{\n\t\tif(particle.parent)\n\t\t\tparticle.parent.removeChild(particle);\n\t}\n\t//decrease count\n\t--this.particleCount;\n};\n\n/**\n * Sets the rotation of the emitter to a new value.\n * @method PIXI.particles.Emitter#rotate\n * @param {Number} newRot The new rotation, in degrees.\n */\np.rotate = function(newRot)\n{\n\tif (this.rotation == newRot) return;\n\t//caclulate the difference in rotation for rotating spawnPos\n\tvar diff = newRot - this.rotation;\n\tthis.rotation = newRot;\n\t//rotate spawnPos\n\tParticleUtils.rotatePoint(diff, this.spawnPos);\n\t//mark the position as having changed\n\tthis._posChanged = true;\n};\n\n/**\n * Changes the spawn position of the emitter.\n * @method PIXI.particles.Emitter#updateSpawnPos\n * @param {Number} x The new x value of the spawn position for the emitter.\n * @param {Number} y The new y value of the spawn position for the emitter.\n */\np.updateSpawnPos = function(x, y)\n{\n\tthis._posChanged = true;\n\tthis.spawnPos.x = x;\n\tthis.spawnPos.y = y;\n};\n\n/**\n * Changes the position of the emitter's owner. You should call this if you are adding\n * particles to the world container that your emitter's owner is moving around in.\n * @method PIXI.particles.Emitter#updateOwnerPos\n * @param {Number} x The new x value of the emitter's owner.\n * @param {Number} y The new y value of the emitter's owner.\n */\np.updateOwnerPos = function(x, y)\n{\n\tthis._posChanged = true;\n\tthis.ownerPos.x = x;\n\tthis.ownerPos.y = y;\n};\n\n/**\n * Prevents emitter position interpolation in the next update.\n * This should be used if you made a major position change of your emitter's owner\n * that was not normal movement.\n * @method PIXI.particles.Emitter#resetPositionTracking\n */\np.resetPositionTracking = function()\n{\n\tthis._prevPosIsValid = false;\n};\n\n/**\n * If particles should be emitted during update() calls. Setting this to false\n * stops new particles from being created, but allows existing ones to die out.\n * @member {Boolean} PIXI.particles.Emitter#emit\n */\nObject.defineProperty(p, \"emit\",\n{\n\tget: function() { return this._emit; },\n\tset: function(value)\n\t{\n\t\tthis._emit = !!value;\n\t\tthis._emitterLife = this.emitterLifetime;\n\t}\n});\n\n/**\n * If the update function is called automatically from the shared ticker.\n * Setting this to false requires calling the update function manually.\n * @member {Boolean} PIXI.particles.Emitter#autoUpdate\n */\nObject.defineProperty(p, \"autoUpdate\",\n{\n\tget: function() { return this._autoUpdate; },\n\tset: function(value)\n\t{\n\t\tif (this._autoUpdate && !value)\n\t\t{\n\t\t\tticker.remove(this.update, this);\n\t\t}\n\t\telse if (!this._autoUpdate && value)\n\t\t{\n\t\t\tticker.add(this.update, this);\n\t\t}\n\t\tthis._autoUpdate = !!value;\n\t}\n});\n\n/**\n * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n * when particle emission is complete.\n * @method PIXI.particles.Emitter#playOnceAndDestroy\n */\np.playOnceAndDestroy = function()\n{\n\tthis.autoUpdate = true;\n\tthis.emit = true;\n\tthis._destroyWhenComplete = true;\n};\n\n/**\n * Updates all particles spawned by this emitter and emits new ones.\n * @method PIXI.particles.Emitter#update\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n */\np.update = function(delta)\n{\n\tif (this._autoUpdate)\n\t{\n\t\tdelta = delta / PIXI.settings.TARGET_FPMS / 1000;\n\t}\n\n\t//if we don't have a parent to add particles to, then don't do anything.\n\t//this also works as a isDestroyed check\n\tif (!this._parent) return;\n\t//update existing particles\n\tvar i, particle, next;\n\tfor (particle = this._activeParticlesFirst; particle; particle = next)\n\t{\n\t\tnext = particle.next;\n\t\tparticle.update(delta);\n\t}\n\tvar prevX, prevY;\n\t//if the previous position is valid, store these for later interpolation\n\tif(this._prevPosIsValid)\n\t{\n\t\tprevX = this._prevEmitterPos.x;\n\t\tprevY = this._prevEmitterPos.y;\n\t}\n\t//store current position of the emitter as local variables\n\tvar curX = this.ownerPos.x + this.spawnPos.x;\n\tvar curY = this.ownerPos.y + this.spawnPos.y;\n\t//spawn new particles\n\tif (this._emit)\n\t{\n\t\t//decrease spawn timer\n\t\tthis._spawnTimer -= delta;\n\t\t//while _spawnTimer < 0, we have particles to spawn\n\t\twhile(this._spawnTimer <= 0)\n\t\t{\n\t\t\t//determine if the emitter should stop spawning\n\t\t\tif(this._emitterLife > 0)\n\t\t\t{\n\t\t\t\tthis._emitterLife -= this._frequency;\n\t\t\t\tif(this._emitterLife <= 0)\n\t\t\t\t{\n\t\t\t\t\tthis._spawnTimer = 0;\n\t\t\t\t\tthis._emitterLife = 0;\n\t\t\t\t\tthis.emit = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//determine if we have hit the particle limit\n\t\t\tif(this.particleCount >= this.maxParticles)\n\t\t\t{\n\t\t\t\tthis._spawnTimer += this._frequency;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//determine the particle lifetime\n\t\t\tvar lifetime;\n\t\t\tif (this.minLifetime == this.maxLifetime)\n\t\t\t\tlifetime = this.minLifetime;\n\t\t\telse\n\t\t\t\tlifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;\n\t\t\t//only make the particle if it wouldn't immediately destroy itself\n\t\t\tif(-this._spawnTimer < lifetime)\n\t\t\t{\n\t\t\t\t//If the position has changed and this isn't the first spawn,\n\t\t\t\t//interpolate the spawn position\n\t\t\t\tvar emitPosX, emitPosY;\n\t\t\t\tif (this._prevPosIsValid && this._posChanged)\n\t\t\t\t{\n\t\t\t\t\t//1 - _spawnTimer / delta, but _spawnTimer is negative\n\t\t\t\t\tvar lerp = 1 + this._spawnTimer / delta;\n\t\t\t\t\temitPosX = (curX - prevX) * lerp + prevX;\n\t\t\t\t\temitPosY = (curY - prevY) * lerp + prevY;\n\t\t\t\t}\n\t\t\t\telse//otherwise just set to the spawn position\n\t\t\t\t{\n\t\t\t\t\temitPosX = curX;\n\t\t\t\t\temitPosY = curY;\n\t\t\t\t}\n\t\t\t\t//create enough particles to fill the wave (non-burst types have a wave of 1)\n\t\t\t\ti = 0;\n\t\t\t\tfor(var len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i)\n\t\t\t\t{\n\t\t\t\t\t//create particle\n\t\t\t\t\tvar p, rand;\n\t\t\t\t\tif(this._poolFirst)\n\t\t\t\t\t{\n\t\t\t\t\t\tp = this._poolFirst;\n\t\t\t\t\t\tthis._poolFirst = this._poolFirst.next;\n\t\t\t\t\t\tp.next = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp = new this.particleConstructor(this);\n\t\t\t\t\t}\n\n\t\t\t\t\t//set a random texture if we have more than one\n\t\t\t\t\tif(this.particleImages.length > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tp.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//if they are actually the same texture, a standard particle\n\t\t\t\t\t\t//will quit early from the texture setting in setTexture().\n\t\t\t\t\t\tp.applyArt(this.particleImages[0]);\n\t\t\t\t\t}\n\t\t\t\t\t//set up the start and end values\n\t\t\t\t\tp.startAlpha = this.startAlpha;\n\t\t\t\t\tp.endAlpha = this.endAlpha;\n\t\t\t\t\tif(this.minimumSpeedMultiplier != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\trand = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;\n\t\t\t\t\t\tp.startSpeed = this.startSpeed * rand;\n\t\t\t\t\t\tp.endSpeed = this.endSpeed * rand;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp.startSpeed = this.startSpeed;\n\t\t\t\t\t\tp.endSpeed = this.endSpeed;\n\t\t\t\t\t}\n\t\t\t\t\tp.acceleration.x = this.acceleration.x;\n\t\t\t\t\tp.acceleration.y = this.acceleration.y;\n\t\t\t\t\tp.maxSpeed = this.maxSpeed;\n\t\t\t\t\tif(this.minimumScaleMultiplier != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\trand = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;\n\t\t\t\t\t\tp.startScale = this.startScale * rand;\n\t\t\t\t\t\tp.endScale = this.endScale * rand;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp.startScale = this.startScale;\n\t\t\t\t\t\tp.endScale = this.endScale;\n\t\t\t\t\t}\n\t\t\t\t\tp.startColor = this.startColor;\n\t\t\t\t\tp.endColor = this.endColor;\n\t\t\t\t\t//randomize the rotation speed\n\t\t\t\t\tif(this.minRotationSpeed == this.maxRotationSpeed)\n\t\t\t\t\t\tp.rotationSpeed = this.minRotationSpeed;\n\t\t\t\t\telse\n\t\t\t\t\t\tp.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;\n\t\t\t\t\tp.noRotation = this.noRotation;\n\t\t\t\t\t//set up the lifetime\n\t\t\t\t\tp.maxLife = lifetime;\n\t\t\t\t\t//set the blend mode\n\t\t\t\t\tp.blendMode = this.particleBlendMode;\n\t\t\t\t\t//set the custom ease, if any\n\t\t\t\t\tp.ease = this.customEase;\n\t\t\t\t\t//set the extra data, if any\n\t\t\t\t\tp.extraData = this.extraData;\n\t\t\t\t\t//call the proper function to handle rotation and position of particle\n\t\t\t\t\tthis._spawnFunc(p, emitPosX, emitPosY, i);\n\t\t\t\t\t//initialize particle\n\t\t\t\t\tp.init();\n\t\t\t\t\t//update the particle by the time passed, so the particles are spread out properly\n\t\t\t\t\tp.update(-this._spawnTimer);//we want a positive delta, because a negative delta messes things up\n\t\t\t\t\t//add the particle to the display list\n\t\t\t\t\tif(!this._parentIsPC || !p.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.addAtBack)\n\t\t\t\t\t\t\tthis._parent.addChildAt(p, 0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthis._parent.addChild(p);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//kind of hacky, but performance friendly\n\t\t\t\t\t\t//shuffle children to correct place\n\t\t\t\t\t\tvar children = this._parent.children;\n\t\t\t\t\t\t//avoid using splice if possible\n\t\t\t\t\t\tif(children[0] == p)\n\t\t\t\t\t\t\tchildren.shift();\n\t\t\t\t\t\telse if(children[children.length-1] == p)\n\t\t\t\t\t\t\tchildren.pop();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar index = children.indexOf(p);\n\t\t\t\t\t\t\tchildren.splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.addAtBack)\n\t\t\t\t\t\t\tchildren.unshift(p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tchildren.push(p);\n\t\t\t\t\t}\n\t\t\t\t\t//add particle to list of active particles\n\t\t\t\t\tif(this._activeParticlesLast)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._activeParticlesLast.next = p;\n\t\t\t\t\t\tp.prev = this._activeParticlesLast;\n\t\t\t\t\t\tthis._activeParticlesLast = p;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._activeParticlesLast = this._activeParticlesFirst = p;\n\t\t\t\t\t}\n\t\t\t\t\t++this.particleCount;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//increase timer and continue on to any other particles that need to be created\n\t\t\tthis._spawnTimer += this._frequency;\n\t\t}\n\t}\n\t//if the position changed before this update, then keep track of that\n\tif(this._posChanged)\n\t{\n\t\tthis._prevEmitterPos.x = curX;\n\t\tthis._prevEmitterPos.y = curY;\n\t\tthis._prevPosIsValid = true;\n\t\tthis._posChanged = false;\n\t}\n\n\t//if we are all done and should destroy ourselves, take care of that\n\tif (this._destroyWhenComplete && !this._emit && !this._activeParticlesFirst)\n\t{\n\t\tthis.destroy();\n\t}\n};\n\n/**\n * Positions a particle for a point type emitter.\n * @method PIXI.particles.Emitter#_spawnPoint\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnPoint = function(p, emitPosX, emitPosY)\n{\n\t//set the initial rotation/direction of the particle based on\n\t//starting particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n\t//drop the particle at the emitter's position\n\tp.position.x = emitPosX;\n\tp.position.y = emitPosY;\n};\n\n/**\n * Positions a particle for a rectangle type emitter.\n * @method PIXI.particles.Emitter#_spawnRect\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnRect = function(p, emitPosX, emitPosY)\n{\n\t//set the initial rotation/direction of the particle based on starting\n\t//particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n\t//place the particle at a random point in the rectangle\n\thelperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;\n\thelperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;\n\tif(this.rotation !== 0)\n\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\tp.position.x = emitPosX + helperPoint.x;\n\tp.position.y = emitPosY + helperPoint.y;\n};\n\n/**\n * Positions a particle for a circle type emitter.\n * @method PIXI.particles.Emitter#_spawnCircle\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnCircle = function(p, emitPosX, emitPosY)\n{\n\t//set the initial rotation/direction of the particle based on starting\n\t//particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\t\tthis.minStartRotation + this.rotation;\n\t//place the particle at a random radius in the circle\n\thelperPoint.x = Math.random() * this.spawnCircle.radius;\n\thelperPoint.y = 0;\n\t//rotate the point to a random angle in the circle\n\tParticleUtils.rotatePoint(Math.random() * 360, helperPoint);\n\t//offset by the circle's center\n\thelperPoint.x += this.spawnCircle.x;\n\thelperPoint.y += this.spawnCircle.y;\n\t//rotate the point by the emitter's rotation\n\tif(this.rotation !== 0)\n\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t//set the position, offset by the emitter's position\n\tp.position.x = emitPosX + helperPoint.x;\n\tp.position.y = emitPosY + helperPoint.y;\n};\n\n/**\n * Positions a particle for a ring type emitter.\n * @method PIXI.particles.Emitter#_spawnRing\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnRing = function(p, emitPosX, emitPosY)\n{\n\tvar spawnCircle = this.spawnCircle;\n\t//set the initial rotation/direction of the particle based on starting\n\t//particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\t\tthis.minStartRotation + this.rotation;\n\t//place the particle at a random radius in the ring\n\tif(spawnCircle.minRadius == spawnCircle.radius)\n\t{\n\t\thelperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +\n\t\t\t\t\t\tspawnCircle.minRadius;\n\t}\n\telse\n\t\thelperPoint.x = spawnCircle.radius;\n\thelperPoint.y = 0;\n\t//rotate the point to a random angle in the circle\n\tvar angle = Math.random() * 360;\n\tp.rotation += angle;\n\tParticleUtils.rotatePoint(angle, helperPoint);\n\t//offset by the circle's center\n\thelperPoint.x += this.spawnCircle.x;\n\thelperPoint.y += this.spawnCircle.y;\n\t//rotate the point by the emitter's rotation\n\tif(this.rotation !== 0)\n\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t//set the position, offset by the emitter's position\n\tp.position.x = emitPosX + helperPoint.x;\n\tp.position.y = emitPosY + helperPoint.y;\n};\n\n/**\n * Positions a particle for a burst type emitter.\n * @method PIXI.particles.Emitter#_spawnBurst\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave.\n */\np._spawnBurst = function(p, emitPosX, emitPosY, i)\n{\n\t//set the initial rotation/direction of the particle based on spawn\n\t//angle and rotation of emitter\n\tif(this.particleSpacing === 0)\n\t\tp.rotation = Math.random() * 360;\n\telse\n\t\tp.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;\n\t//drop the particle at the emitter's position\n\tp.position.x = emitPosX;\n\tp.position.y = emitPosY;\n};\n\n/**\n * Kills all active particles immediately.\n * @method PIXI.particles.Emitter#cleanup\n */\np.cleanup = function()\n{\n\tvar particle, next;\n\tfor (particle = this._activeParticlesFirst; particle; particle = next)\n\t{\n\t\tnext = particle.next;\n\t\tthis.recycle(particle);\n\t\tif(particle.parent)\n\t\t\tparticle.parent.removeChild(particle);\n\t}\n\tthis._activeParticlesFirst = this._activeParticlesLast = null;\n\tthis.particleCount = 0;\n};\n\n/**\n * Destroys the emitter and all of its particles.\n * @method PIXI.particles.Emitter#destroy\n */\np.destroy = function()\n{\n\t//make sure we aren't still listening to any tickers\n\tthis.autoUpdate = false;\n\t//puts all active particles in the pool, and removes them from the particle parent\n\tthis.cleanup();\n\t//wipe the pool clean\n\tvar next;\n\tfor (var particle = this._poolFirst; particle; particle = next)\n\t{\n\t\t//store next value so we don't lose it in our destroy call\n\t\tnext = particle.next;\n\t\tparticle.destroy();\n\t}\n\tthis._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =\n\t\tthis.startColor = this.endColor = this.customEase = null;\n};\n\nmodule.exports = Emitter;\n\n\n// WEBPACK FOOTER //\n// src/Emitter.js","var ParticleUtils = require(\"./ParticleUtils\");\nvar Sprite = PIXI.Sprite;\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n * @memberof PIXI.particles\n * @class Particle\n * @extends PIXI.Sprite\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\n */\nvar Particle = function(emitter)\n{\n\t//start off the sprite with a blank texture, since we are going to replace it\n\t//later when the particle is initialized.\n\tSprite.call(this);\n\n\t/**\n\t * The emitter that controls this particle.\n\t * @property {Emitter} emitter\n\t */\n\tthis.emitter = emitter;\n\t//particles should be centered\n\tthis.anchor.x = this.anchor.y = 0.5;\n\t/**\n\t * The velocity of the particle. Speed may change, but the angle also\n\t * contained in velocity is constant.\n\t * @property {PIXI.Point} velocity\n\t */\n\tthis.velocity = new PIXI.Point();\n\t/**\n\t * The maximum lifetime of this particle, in seconds.\n\t * @property {Number} maxLife\n\t */\n\tthis.maxLife = 0;\n\t/**\n\t * The current age of the particle, in seconds.\n\t * @property {Number} age\n\t */\n\tthis.age = 0;\n\t/**\n\t * A simple easing function to be applied to all properties that\n\t * are being interpolated.\n\t * @property {Function} ease\n\t */\n\tthis.ease = null;\n\t/**\n\t * Extra data that the emitter passes along for custom particles.\n\t * @property {Object} extraData\n\t */\n\tthis.extraData = null;\n\t/**\n\t * The alpha of the particle at the start of its life.\n\t * @property {Number} startAlpha\n\t */\n\tthis.startAlpha = 0;\n\t/**\n\t * The alpha of the particle at the end of its life.\n\t * @property {Number} endAlpha\n\t */\n\tthis.endAlpha = 0;\n\t/**\n\t * The speed of the particle at the start of its life.\n\t * @property {Number} startSpeed\n\t */\n\tthis.startSpeed = 0;\n\t/**\n\t * The speed of the particle at the end of its life.\n\t * @property {Number} endSpeed\n\t */\n\tthis.endSpeed = 0;\n\t/**\n\t * Acceleration to apply to the particle.\n\t * @property {PIXI.Point} accleration\n\t */\n\tthis.acceleration = new PIXI.Point();\n\t/**\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n\t * will disable the maximum speed.\n\t * @property {Number} maxSpeed\n\t * @default NaN\n\t */\n\tthis.maxSpeed = NaN;\n\t/**\n\t * The scale of the particle at the start of its life.\n\t * @property {Number} startScale\n\t */\n\tthis.startScale = 0;\n\t/**\n\t * The scale of the particle at the start of its life.\n\t * @property {Number} endScale\n\t */\n\tthis.endScale = 0;\n\t/**\n\t * The tint of the particle at the start of its life.\n\t * @property {Array} startColor\n\t */\n\tthis.startColor = null;\n\t/**\n\t * The red tint of the particle at the start of its life.\n\t * This is pulled from startColor in init().\n\t * @property {uint} _sR\n\t * @private\n\t */\n\tthis._sR = 0;\n\t/**\n\t * The green tint of the particle at the start of its life.\n\t * This is pulled from startColor in init().\n\t * @property {uint} _sG\n\t * @private\n\t */\n\tthis._sG = 0;\n\t/**\n\t * The blue tint of the particle at the start of its life.\n\t * This is pulled from startColor in init().\n\t * @property {uint} _sB\n\t * @private\n\t */\n\tthis._sB = 0;\n\t/**\n\t * The tint of the particle at the start of its life.\n\t * @property {Array} endColor\n\t */\n\tthis.endColor = null;\n\t/**\n\t * The red tint of the particle at the end of its life.\n\t * This is pulled from endColor in init().\n\t * @property {uint} _eR\n\t * @private\n\t */\n\tthis._eR = 0;\n\t/**\n\t * The green tint of the particle at the end of its life.\n\t * This is pulled from endColor in init().\n\t * @property {uint} _sG\n\t * @private\n\t */\n\tthis._eG = 0;\n\t/**\n\t * The blue tint of the particle at the end of its life.\n\t * This is pulled from endColor in init().\n\t * @property {uint} _sB\n\t * @private\n\t */\n\tthis._eB = 0;\n\t/**\n\t * If alpha should be interpolated at all.\n\t * @property {Boolean} _doAlpha\n\t * @private\n\t */\n\tthis._doAlpha = false;\n\t/**\n\t * If scale should be interpolated at all.\n\t * @property {Boolean} _doScale\n\t * @private\n\t */\n\tthis._doScale = false;\n\t/**\n\t * If speed should be interpolated at all.\n\t * @property {Boolean} _doSpeed\n\t * @private\n\t */\n\tthis._doSpeed = false;\n\t/**\n\t * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\n\t * and _doSpeed gets priority.\n\t * @property {Boolean} _doAcceleration\n\t * @private\n\t */\n\tthis._doAcceleration = false;\n\t/**\n\t * If color should be interpolated at all.\n\t * @property {Boolean} _doColor\n\t * @private\n\t */\n\tthis._doColor = false;\n\t/**\n\t * If normal movement should be handled. Subclasses wishing to override movement\n\t * can set this to false in init().\n\t * @property {Boolean} _doNormalMovement\n\t * @private\n\t */\n\tthis._doNormalMovement = false;\n\t/**\n\t * One divided by the max life of the particle, saved for slightly faster math.\n\t * @property {Number} _oneOverLife\n\t * @private\n\t */\n\tthis._oneOverLife = 0;\n\n\t/**\n\t * Reference to the next particle in the list.\n\t * @property {Particle} next\n\t * @private\n\t */\n\tthis.next = null;\n\n\t/**\n\t * Reference to the previous particle in the list.\n\t * @property {Particle} prev\n\t * @private\n\t */\n\tthis.prev = null;\n\n\t//save often used functions on the instance instead of the prototype for better speed\n\tthis.init = this.init;\n\tthis.Particle_init = this.Particle_init;\n\tthis.update = this.update;\n\tthis.Particle_update = this.Particle_update;\n\tthis.applyArt = this.applyArt;\n\tthis.kill = this.kill;\n};\n\n// Reference to the prototype\nvar p = Particle.prototype = Object.create(Sprite.prototype);\n\n/**\n * Initializes the particle for use, based on the properties that have to\n * have been set already on the particle.\n * @method PIXI.particles.Particle#init\n */\n/**\n * A reference to init, so that subclasses can access it without the penalty of Function.call()\n * @method PIXI.particles.Particle#Particle_init\n * @protected\n */\np.init = p.Particle_init = function()\n{\n\t//reset the age\n\tthis.age = 0;\n\t//set up the velocity based on the start speed and rotation\n\tthis.velocity.x = this.startSpeed;\n\tthis.velocity.y = 0;\n\tParticleUtils.rotatePoint(this.rotation, this.velocity);\n\tif (this.noRotation)\n\t{\n\t\tthis.rotation = 0;\n\t}\n\telse\n\t{\n\t\t//convert rotation to Radians from Degrees\n\t\tthis.rotation *= ParticleUtils.DEG_TO_RADS;\n\t}\n\t//convert rotation speed to Radians from Degrees\n\tthis.rotationSpeed *= ParticleUtils.DEG_TO_RADS;\n\t//set alpha to inital alpha\n\tthis.alpha = this.startAlpha;\n\t//set scale to initial scale\n\tthis.scale.x = this.scale.y = this.startScale;\n\t//determine start and end color values\n\tif (this.startColor)\n\t{\n\t\tthis._sR = this.startColor[0];\n\t\tthis._sG = this.startColor[1];\n\t\tthis._sB = this.startColor[2];\n\t\tif(this.endColor)\n\t\t{\n\t\t\tthis._eR = this.endColor[0];\n\t\t\tthis._eG = this.endColor[1];\n\t\t\tthis._eB = this.endColor[2];\n\t\t}\n\t}\n\t//figure out what we need to interpolate\n\tthis._doAlpha = this.startAlpha != this.endAlpha;\n\tthis._doSpeed = this.startSpeed != this.endSpeed;\n\tthis._doScale = this.startScale != this.endScale;\n\tthis._doColor = !!this.endColor;\n\tthis._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;\n\t//_doNormalMovement can be cancelled by subclasses\n\tthis._doNormalMovement = this._doSpeed || this.startSpeed !== 0 || this._doAcceleration;\n\t//save our lerp helper\n\tthis._oneOverLife = 1 / this.maxLife;\n\t//set the inital color\n\tthis.tint = ParticleUtils.combineRGBComponents(this._sR, this._sG, this._sB);\n\t//ensure visibility\n\tthis.visible = true;\n};\n\n/**\n * Sets the texture for the particle. This can be overridden to allow\n * for an animated particle.\n * @method PIXI.particles.Particle#applyArt\n * @param {PIXI.Texture} art The texture to set.\n */\np.applyArt = function(art)\n{\n\tthis.texture = art || ParticleUtils.EMPTY_TEXTURE;\n};\n\n/**\n * Updates the particle.\n * @method PIXI.particles.Particle#update\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\n *                   properties. A value of -1 means the particle died of old age instead.\n */\n/**\n * A reference to update so that subclasses can access the original without the overhead\n * of Function.call().\n * @method PIXI.particles.Particle#Particle_update\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\n *                   properties. A value of -1 means the particle died of old age instead.\n * @protected\n */\np.update = p.Particle_update = function(delta)\n{\n\t//increase age\n\tthis.age += delta;\n\t//recycle particle if it is too old\n\tif(this.age >= this.maxLife)\n\t{\n\t\tthis.kill();\n\t\treturn -1;\n\t}\n\n\t//determine our interpolation value\n\tvar lerp = this.age * this._oneOverLife;//lifetime / maxLife;\n\tif (this.ease)\n\t{\n\t\tif(this.ease.length == 4)\n\t\t{\n\t\t\t//the t, b, c, d parameters that some tween libraries use\n\t\t\t//(time, initial value, end value, duration)\n\t\t\tlerp = this.ease(lerp, 0, 1, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//the simplified version that we like that takes\n\t\t\t//one parameter, time from 0-1. TweenJS eases provide this usage.\n\t\t\tlerp = this.ease(lerp);\n\t\t}\n\t}\n\n\t//interpolate alpha\n\tif (this._doAlpha)\n\t\tthis.alpha = (this.endAlpha - this.startAlpha) * lerp + this.startAlpha;\n\t//interpolate scale\n\tif (this._doScale)\n\t{\n\t\tvar scale = (this.endScale - this.startScale) * lerp + this.startScale;\n\t\tthis.scale.x = this.scale.y = scale;\n\t}\n\t//handle movement\n\tif(this._doNormalMovement)\n\t{\n\t\t//interpolate speed\n\t\tif (this._doSpeed)\n\t\t{\n\t\t\tvar speed = (this.endSpeed - this.startSpeed) * lerp + this.startSpeed;\n\t\t\tParticleUtils.normalize(this.velocity);\n\t\t\tParticleUtils.scaleBy(this.velocity, speed);\n\t\t}\n\t\telse if(this._doAcceleration)\n\t\t{\n\t\t\tthis.velocity.x += this.acceleration.x * delta;\n\t\t\tthis.velocity.y += this.acceleration.y * delta;\n\t\t\tif (this.maxSpeed)\n\t\t\t{\n\t\t\t\tvar currentSpeed = ParticleUtils.length(this.velocity);\n\t\t\t\t//if we are going faster than we should, clamp at the max speed\n\t\t\t\t//DO NOT recalculate vector length\n\t\t\t\tif (currentSpeed > this.maxSpeed)\n\t\t\t\t{\n\t\t\t\t\tParticleUtils.scaleBy(this.velocity, this.maxSpeed / currentSpeed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//adjust position based on velocity\n\t\tthis.position.x += this.velocity.x * delta;\n\t\tthis.position.y += this.velocity.y * delta;\n\t}\n\t//interpolate color\n\tif (this._doColor)\n\t{\n\t\tvar r = (this._eR - this._sR) * lerp + this._sR;\n\t\tvar g = (this._eG - this._sG) * lerp + this._sG;\n\t\tvar b = (this._eB - this._sB) * lerp + this._sB;\n\t\tthis.tint = ParticleUtils.combineRGBComponents(r, g, b);\n\t}\n\t//update rotation\n\tif(this.rotationSpeed !== 0)\n\t{\n\t\tthis.rotation += this.rotationSpeed * delta;\n\t}\n\telse if(this.acceleration && !this.noRotation)\n\t{\n\t\tthis.rotation = Math.atan2(this.velocity.y, this.velocity.x);// + Math.PI / 2;\n\t}\n\treturn lerp;\n};\n\n/**\n * Kills the particle, removing it from the display list\n * and telling the emitter to recycle it.\n * @method PIXI.particles.Particle#kill\n */\np.kill = function()\n{\n\tthis.emitter.recycle(this);\n};\n\np.Sprite_Destroy = Sprite.prototype.destroy;\n/**\n * Destroys the particle, removing references and preventing future use.\n * @method PIXI.particles.Particle#destroy\n */\np.destroy = function()\n{\n\tif (this.parent)\n\t\tthis.parent.removeChild(this);\n\tif (this.Sprite_Destroy)\n\t\tthis.Sprite_Destroy();\n\tthis.emitter = this.velocity = this.startColor = this.endColor = this.ease =\n\t\tthis.next = this.prev = null;\n};\n\n/**\n * Checks over the art that was passed to the Emitter's init() function, to do any special\n * modifications to prepare it ahead of time.\n * @method PIXI.particles.Particle.parseArt\n * @static\n * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\n *                     Any strings in the array will be converted to Textures via\n *                     Texture.fromImage().\n * @return {Array} The art, after any needed modifications.\n */\nParticle.parseArt = function(art)\n{\n\t//convert any strings to Textures.\n\tvar i;\n\tfor(i = art.length; i >= 0; --i)\n\t{\n\t\tif(typeof art[i] == \"string\")\n\t\t\tart[i] = PIXI.Texture.fromImage(art[i]);\n\t}\n\t//particles from different base textures will be slower in WebGL than if they\n\t//were from one spritesheet\n\tif(ParticleUtils.verbose)\n\t{\n\t\tfor(i = art.length - 1; i > 0; --i)\n\t\t{\n\t\t\tif(art[i].baseTexture != art[i - 1].baseTexture)\n\t\t\t{\n\t\t\t\tif (window.console)\n\t\t\t\t\tconsole.warn(\"PixiParticles: using particle textures from different images may hinder performance in WebGL\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn art;\n};\n\n/**\n * Parses extra emitter data to ensure it is set up for this particle class.\n * Particle does nothing to the extra data.\n * @method PIXI.particles.Particle.parseData\n * @static\n * @param  {Object} extraData The extra data from the particle config.\n * @return {Object} The parsed extra data.\n */\nParticle.parseData = function(extraData)\n{\n\treturn extraData;\n};\n\nmodule.exports = Particle;\n\n\n// WEBPACK FOOTER //\n// src/Particle.js","\"use strict\";\n\nvar BLEND_MODES = PIXI.BLEND_MODES || PIXI.blendModes;\nvar Texture = PIXI.Texture;\n\n/**\n * Contains helper functions for particles and emitters to use.\n * @memberof PIXI.particles\n * @class ParticleUtils\n * @static\n */\nvar ParticleUtils = {};\n\n/**\n * If errors and warnings should be logged within the library.\n * @name PIXI.particles.ParticleUtils.verbose\n * @default false\n * @static\n */\nParticleUtils.verbose = false;\n\nvar DEG_TO_RADS = ParticleUtils.DEG_TO_RADS = Math.PI / 180;\n\nvar empty = ParticleUtils.EMPTY_TEXTURE = Texture.EMPTY;\n//prevent any events from being used on the empty texture, as well as destruction of it\n//v4 of Pixi does this, but doing it again won't hurt\nempty.on = empty.destroy = empty.once = empty.emit = function() {};\n\n/**\n * Rotates a point by a given angle.\n * @method PIXI.particles.ParticleUtils.rotatePoint\n * @param {Number} angle The angle to rotate by in degrees\n * @param {PIXI.Point} p The point to rotate around 0,0.\n * @static\n */\nParticleUtils.rotatePoint = function(angle, p)\n{\n\tif(!angle) return;\n\tangle *= DEG_TO_RADS;\n\tvar s = Math.sin(angle);\n\tvar c = Math.cos(angle);\n\tvar xnew = p.x * c - p.y * s;\n\tvar ynew = p.x * s + p.y * c;\n\tp.x = xnew;\n\tp.y = ynew;\n};\n\n/**\n * Combines separate color components (0-255) into a single uint color.\n * @method PIXI.particles.ParticleUtils.combineRGBComponents\n * @param {uint} r The red value of the color\n * @param {uint} g The green value of the color\n * @param {uint} b The blue value of the color\n * @return {uint} The color in the form of 0xRRGGBB\n * @static\n */\nParticleUtils.combineRGBComponents = function(r, g, b/*, a*/)\n{\n\treturn /*a << 24 |*/ r << 16 | g << 8 | b;\n};\n\n/**\n * Reduces the point to a length of 1.\n * @method PIXI.particles.ParticleUtils.normalize\n * @static\n * @param {PIXI.Point} point The point to normalize\n */\nParticleUtils.normalize = function(point)\n{\n\tvar oneOverLen = 1 / ParticleUtils.length(point);\n\tpoint.x *= oneOverLen;\n\tpoint.y *= oneOverLen;\n};\n\n/**\n * Multiplies the x and y values of this point by a value.\n * @method PIXI.particles.ParticleUtils.scaleBy\n * @static\n * @param {PIXI.Point} point The point to scaleBy\n * @param value {Number} The value to scale by.\n */\nParticleUtils.scaleBy = function(point, value)\n{\n\tpoint.x *= value;\n\tpoint.y *= value;\n};\n\n/**\n * Returns the length (or magnitude) of this point.\n * @method PIXI.particles.ParticleUtils.length\n * @static\n * @param {PIXI.Point} point The point to measure length\n * @return The length of this point.\n */\nParticleUtils.length = function(point)\n{\n\treturn Math.sqrt(point.x * point.x + point.y * point.y);\n};\n\n/**\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n * \"AARRGGBB\", or \"RRGGBB\" to an array of ints of 0-255 or Numbers from 0-1, as\n * [r, g, b, (a)].\n * @method PIXI.particles.ParticleUtils.hexToRGB\n * @param {String} color The input color string.\n * @param {Array} output An array to put the output in. If omitted, a new array is created.\n * @return The array of numeric color values.\n * @static\n */\nParticleUtils.hexToRGB = function(color, output)\n{\n\tif (output)\n\t\toutput.length = 0;\n\telse\n\t\toutput = [];\n\tif (color.charAt(0) == \"#\")\n\t\tcolor = color.substr(1);\n\telse if (color.indexOf(\"0x\") === 0)\n\t\tcolor = color.substr(2);\n\tvar alpha;\n\tif (color.length == 8)\n\t{\n\t\talpha = color.substr(0, 2);\n\t\tcolor = color.substr(2);\n\t}\n\toutput.push(parseInt(color.substr(0, 2), 16));//Red\n\toutput.push(parseInt(color.substr(2, 2), 16));//Green\n\toutput.push(parseInt(color.substr(4, 2), 16));//Blue\n\tif (alpha)\n\t\toutput.push(parseInt(alpha, 16));\n\treturn output;\n};\n\n/**\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n * by the related tool at http://www.greensock.com/customease/.\n * @method PIXI.particles.ParticleUtils.generateEase\n * @param {Array} segments An array of segments, as created by\n * http://www.greensock.com/customease/.\n * @return {Function} A function that calculates the percentage of change at\n *                    a given point in time (0-1 inclusive).\n * @static\n */\nParticleUtils.generateEase = function(segments)\n{\n\tvar qty = segments.length;\n\tvar oneOverQty = 1 / qty;\n\t/*\n\t * Calculates the percentage of change at a given point in time (0-1 inclusive).\n\t * @param {Number} time The time of the ease, 0-1 inclusive.\n\t * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n\t *                  ease goes outside those bounds).\n\t */\n\tvar simpleEase = function(time)\n\t{\n\t\tvar t, s;\n\t\tvar i = (qty * time) | 0;//do a quick floor operation\n\t\tt = (time - (i * oneOverQty)) * qty;\n\t\ts = segments[i] || segments[qty - 1];\n\t\treturn (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));\n\t};\n\treturn simpleEase;\n};\n\n/**\n * Gets a blend mode, ensuring that it is valid.\n * @method PIXI.particles.ParticleUtils.getBlendMode\n * @param {String} name The name of the blend mode to get.\n * @return {int} The blend mode as specified in the PIXI.blendModes enumeration.\n * @static\n */\nParticleUtils.getBlendMode = function(name)\n{\n\tif (!name) return BLEND_MODES.NORMAL;\n\tname = name.toUpperCase();\n\twhile (name.indexOf(\" \") >= 0)\n\t\tname = name.replace(\" \", \"_\");\n\treturn BLEND_MODES[name] || BLEND_MODES.NORMAL;\n};\n\nmodule.exports = ParticleUtils;\n\n\n// WEBPACK FOOTER //\n// src/ParticleUtils.js","\"use strict\";\n\nvar ParticleUtils = require(\"./ParticleUtils\"),\n\tParticle = require(\"./Particle\");\n\n/**\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the particle config must have a \"path\" string in the\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\n * speed settings of the particle). It may have numbers, parentheses, the four basic\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\n * \"acos\", \"atan\", \"atan2\", \"log\".\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * Some example paths:\n *\n * \t\"sin(x/10) * 20\" // A sine wave path.\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\n *\n * @memberof PIXI.particles\n * @class PathParticle\n * @extends PIXI.particles.Particle\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\n */\nvar PathParticle = function(emitter)\n{\n\tParticle.call(this, emitter);\n\t/**\n\t * The function representing the path the particle should take.\n\t * @property {Function} path\n\t */\n\tthis.path = null;\n\t/**\n\t * The initial rotation in degrees of the particle, because the direction of the path\n\t * is based on that.\n\t * @property {Number} initialRotation\n\t */\n\tthis.initialRotation = 0;\n\t/**\n\t * The initial position of the particle, as all path movement is added to that.\n\t * @property {PIXI.Point} initialPosition\n\t */\n\tthis.initialPosition = new PIXI.Point();\n\t/**\n\t * Total single directional movement, due to speed.\n\t * @property {Number} movement\n\t */\n\tthis.movement = 0;\n};\n\n// Reference to the super class\nvar s = Particle.prototype;\n// Reference to the prototype\nvar p = PathParticle.prototype = Object.create(s);\n\n/**\n * A helper point for math things.\n * @property {Function} helperPoint\n * @private\n * @static\n */\nvar helperPoint = new PIXI.Point();\n\n/**\n * Initializes the particle for use, based on the properties that have to\n * have been set already on the particle.\n * @method PIXI.particles.PathParticle#init\n */\np.init = function()\n{\n\t//get initial rotation before it is converted to radians\n\tthis.initialRotation = this.rotation;\n\t//standard init\n\tthis.Particle_init();\n\n\t//set the path for the particle\n\tthis.path = this.extraData.path;\n\t//cancel the normal movement behavior\n\tthis._doNormalMovement = !this.path;\n\t//reset movement\n\tthis.movement = 0;\n\t//grab position\n\tthis.initialPosition.x = this.position.x;\n\tthis.initialPosition.y = this.position.y;\n};\n\n//a hand picked list of Math functions (and a couple properties) that are allowable.\n//they should be used without the preceding \"Math.\"\nvar MATH_FUNCS =\n[\n\t\"pow\",\n\t\"sqrt\",\n\t\"abs\",\n\t\"floor\",\n\t\"round\",\n\t\"ceil\",\n\t\"E\",\n\t\"PI\",\n\t\"sin\",\n\t\"cos\",\n\t\"tan\",\n\t\"asin\",\n\t\"acos\",\n\t\"atan\",\n\t\"atan2\",\n\t\"log\"\n];\n//Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n//as 'x', for the variable usage.\nvar WHITELISTER = \"[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]\";\n//add the math functions to the regex string.\nfor(var index = MATH_FUNCS.length - 1; index >= 0; --index)\n{\n\tWHITELISTER += \"|\" + MATH_FUNCS[index];\n}\n//create an actual regular expression object from the string\nWHITELISTER = new RegExp(WHITELISTER, \"g\");\n\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using eval() to generate a function.\n * @method PIXI.particles.PathParticle~parsePath\n * @private\n * @static\n * @param {String} pathString The string to parse.\n * @return {Function} The path function - takes x, outputs y.\n */\nvar parsePath = function(pathString)\n{\n\tvar rtn;\n\tvar matches = pathString.match(WHITELISTER);\n\tfor(var i = matches.length - 1; i >= 0; --i)\n\t{\n\t\tif(MATH_FUNCS.indexOf(matches[i]) >= 0)\n\t\t\tmatches[i] = \"Math.\" + matches[i];\n\t}\n\tpathString = matches.join(\"\");\n\teval(\"rtn = function(x){ return \" + pathString + \"; };\");// jshint ignore:line\n\treturn rtn;\n};\n\n/**\n * Updates the particle.\n * @method PIXI.particles.PathParticle#update\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n */\np.update = function(delta)\n{\n\tvar lerp = this.Particle_update(delta);\n\t//if the particle died during the update, then don't bother\n\tif(lerp >= 0 && this.path)\n\t{\n\t\t//increase linear movement based on speed\n\t\tvar speed = (this.endSpeed - this.startSpeed) * lerp + this.startSpeed;\n\t\tthis.movement += speed * delta;\n\t\t//set up the helper point for rotation\n\t\thelperPoint.x = this.movement;\n\t\thelperPoint.y = this.path(this.movement);\n\t\tParticleUtils.rotatePoint(this.initialRotation, helperPoint);\n\t\tthis.position.x = this.initialPosition.x + helperPoint.x;\n\t\tthis.position.y = this.initialPosition.y + helperPoint.y;\n\t}\n};\n\np.Particle_destroy = Particle.prototype.destroy;\n/**\n * Destroys the particle, removing references and preventing future use.\n * @method PIXI.particles.PathParticle#destroy\n */\np.destroy = function()\n{\n\tthis.Particle_destroy();\n\tthis.path = this.initialPosition = null;\n};\n\n/**\n * Checks over the art that was passed to the Emitter's init() function, to do any special\n * modifications to prepare it ahead of time. This just runs Particle.parseArt().\n * @method PIXI.particles.PathParticle.parseArt\n * @static\n * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\n *                     Any strings in the array will be converted to Textures via\n *                     Texture.fromImage().\n * @return {Array} The art, after any needed modifications.\n */\nPathParticle.parseArt = function(art)\n{\n\treturn Particle.parseArt(art);\n};\n\n/**\n * Parses extra emitter data to ensure it is set up for this particle class.\n * PathParticle checks for the existence of path data, and parses the path data for use\n * by particle instances.\n * @method PIXI.particles.PathParticle.parseData\n * @static\n * @param  {Object} extraData The extra data from the particle config.\n * @return {Object} The parsed extra data.\n */\nPathParticle.parseData = function(extraData)\n{\n\tvar output = {};\n\tif(extraData && extraData.path)\n\t{\n\t\ttry\n\t\t{\n\t\t\toutput.path = parsePath(extraData.path);\n\t\t}\n\t\tcatch(e)\n\t\t{\n\t\t\tif(ParticleUtils.verbose)\n\t\t\t\tconsole.error(\"PathParticle: error in parsing path expression\");\n\t\t\toutput.path = null;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(ParticleUtils.verbose)\n\t\t\tconsole.error(\"PathParticle requires a path string in extraData!\");\n\t\toutput.path = null;\n\t}\n\treturn output;\n};\n\nmodule.exports = PathParticle;\n\n\n// WEBPACK FOOTER //\n// src/PathParticle.js","exports.ParticleUtils = require(\"./ParticleUtils.js\");\nexports.Particle = require(\"./Particle.js\");\nexports.Emitter = require(\"./Emitter.js\");\nexports.PathParticle = require(\"./PathParticle.js\");\nexports.AnimatedParticle = require(\"./AnimatedParticle.js\");\nrequire(\"./deprecation.js\");\n\n\n// WEBPACK FOOTER //\n// src/particles.js","\"use strict\";\n\n// Check for window, fallback to global\nvar global = typeof window !== 'undefined' ? window : GLOBAL;\n\n//ensure that the particles namespace exist - PIXI 4 creates it itself, PIXI 3 does not\nif (!global.PIXI.particles) {\n\tglobal.PIXI.particles = {};\n}\n\n// Export for Node-compatible environments like Electron\nif (typeof module !== 'undefined' && module.exports)\n{\n\t// Attempt to require the pixi module\n\tif (typeof PIXI === 'undefined')\n\t{\n\t\t// Include the Pixi.js module\n\t\trequire('pixi.js');\n\t}\n\n\t// Export the module\n\tmodule.exports = global.PIXI.particles || particles;\n}\n// If we're in the browser make sure PIXI is available\nelse if (typeof PIXI === 'undefined')\n{\n\tthrow \"pixi-particles requires pixi.js to be loaded first\";\n}\n\n// get the library itself\nvar particles = require('./particles');\n\n// insert the lirbary into the particles namespace on PIXI\nfor (var prop in particles) {\n\tglobal.PIXI.particles[prop] = particles[prop];\n}\n\n\n// WEBPACK FOOTER //\n// src"],"sourceRoot":""}